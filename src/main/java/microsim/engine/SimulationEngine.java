package microsim.engine;

import cern.jet.random.engine.MersenneTwister;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.java.Log;
import microsim.data.ExperimentManager;
import microsim.data.db.Experiment;
import microsim.event.EventQueue;
import microsim.event.SystemEventType;
import microsim.exception.SimulationException;
import microsim.exception.SimulationRuntimeException;
import org.jetbrains.annotations.Nullable;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;

/**
 * The simulation engine. The engine keeps a reference to an {@code EventQueue} object to manage temporal sequence of
 * events. Every object of the running simulation can schedule events at a specified time point and the engine will
 * notify to it at the right time. The SimEngine stores a list of windows created by models.
 */
@Log
public class SimulationEngine extends Thread {

    /**
     * Returns a reference to the current Random generator.
     */
    @Getter
    private static MersenneTwister rnd;
    private static SimulationEngine instance;
    @Getter
    protected ArrayList<EngineListener> engineListeners;

    /**
     * Sets the delay time beetween two simulation steps, ms.
     */
    @Setter
    private int eventThresold = 0;
    @Setter
    @Getter
    private int currentRunNumber = 1;
    private Experiment currentExperiment = null;
    @Setter
    @Getter
    private String multiRunId = null;

    /**
     * Returns a reference to the current EventQueue.
     */
    @Getter
    private EventQueue eventQueue;
    private List<SimulationManager> models;
    private Map<String, SimulationManager> modelMap;
    private boolean modelBuild = false;

    /**
     * Returns the current random seed.
     */
    @Getter
    private int randomSeed;
    @Getter
    private boolean runningStatus = false;
    /**
     * If set to true during the build phase of a simulation, the simulation run will not be connected to an
     * input / output database. This may speed up the building and execution of the simulation, however the relational
     * database management features provided by JAS-mine cannot then be used and data cannot be persisted to the output
     * database. Any data should be exported to CSV files instead. If an attempt is made to import data from an input
     * database during the simulation, an exception will be thrown.
     */
    @Getter
    private boolean turnOffDatabaseConnection = false;
    @Getter
    private boolean turnOffDatabaseConnectionAvailable = true;
    @Setter
    @Getter
    private ClassLoader classLoader = null;
    @Getter
    private final Class<?> builderClass = null;

    @Setter
    @Getter
    private ExperimentBuilder experimentBuilder = null;

    protected SimulationEngine() {
        eventQueue = new EventQueue();
        models = new ArrayList<>();
        modelMap = new HashMap<>();
        randomSeed = (int) System.currentTimeMillis();
        rnd = new MersenneTwister(randomSeed);
        engineListeners = new ArrayList<>();

        instance = this;
    }

    public static @NonNull SimulationEngine getInstance() {
        return instance == null ? new SimulationEngine() : instance;
    }

    public void setTurnOffDatabaseConnection(final boolean turnOffDatabaseConnection) {
        if (turnOffDatabaseConnection && !turnOffDatabaseConnectionAvailable) return;

        this.turnOffDatabaseConnection = turnOffDatabaseConnection;
        ExperimentManager.getInstance().saveExperimentToDatabase = !turnOffDatabaseConnection;
    }

    public @Nullable SimulationManager getManager(final @Nullable String id) {
        return modelMap.get(id);
    }


    /**
     * Install a listener for events generated by the simulation engine.
     *
     * @param engineListener An object implementing the ISimEngineListener interface.
     */
    public void addEngineListener(EngineListener engineListener) {
        engineListeners.add(engineListener);
    }

    public void removeEngineListener(EngineListener engineListener) {
        engineListeners.remove(engineListener);
    }

    public void setup() {
        if (builderClass != null)
            try {
                ((ExperimentBuilder) builderClass.getDeclaredConstructor().newInstance()).buildExperiment(this);
            } catch (InstantiationException | IllegalAccessException | NoSuchMethodException |
                     InvocationTargetException e) {
                log.log(Level.SEVERE, e.getMessage());
            }
        else if (experimentBuilder != null)
            experimentBuilder.buildExperiment(this);

        notifySimulationListeners(SystemEventType.Setup);
    }

    /**
     * Return an array representing the running SimModels.
     *
     * @return A list of running models.
     */
    public SimulationManager[] getModelArray() {
        return models.toArray(new SimulationManager[]{});
    }

    /**
     * Return a reference to the current SimTime.
     *
     * @return The current time object.
     */
    public double getTime() {
        return eventQueue.getTime();
    }

    /**
     * Make forSteps simulation steps.
     *
     * @param forSteps The number of steps to be done.
     * @throws SimulationException //TODO finish this
     */
    public void step(int forSteps) throws SimulationException {
        for (int i = 0; i < forSteps; i++) step();
    }

    public void reset() {
        pause();
        eventQueue = new EventQueue();
        models = new ArrayList<>();
        modelMap = new HashMap<>();
        randomSeed = (int) System.currentTimeMillis();
        rnd = new MersenneTwister(randomSeed);
    }

    /**
     * Start simulation. A new thread starts and calls step() method until something stops it.
     */
    public void startSimulation() {
        if (!isAlive()) start();
        if (!modelBuild) buildModels();

        setRunningStatus(true);
        notifySimulationListeners(SystemEventType.Start);
    }

    /**
     * Stop simulation. The running thread is frozen until next step is called.
     */
    public void pause() {
        setRunningStatus(false);
        notifySimulationListeners(SystemEventType.Stop);
    }

    /**
     * Stops the simulation and then quits the JVM.
     */
    public void quit() {
        pause();
        System.exit(0);
    }

    /**
     * Notifies the engine to manage a SimModel. This method is mandatory to let the model work. The current event queue
     * is joined to the given model.
     */
    public SimulationManager addSimulationManager(SimulationManager simulationManager) {
        modelMap.put(simulationManager.getId(), simulationManager);
        models.add(simulationManager);
        simulationManager.setEngine(this);

        return simulationManager;
    }

    public SimulationManager addSimulationManager(String managerClassName) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
        SimulationManager simulationManager;
        if (classLoader != null)
            simulationManager = (SimulationManager) classLoader.loadClass(managerClassName).newInstance();
        else
            simulationManager = (SimulationManager) Class.forName(managerClassName).newInstance();
        return addSimulationManager(simulationManager);
    }

    /**
     * Call the buildModel() method of each active SimModel.
     */
    public void buildModels() {
        currentExperiment = ExperimentManager.getInstance().createExperiment(multiRunId);

        turnOffDatabaseConnectionAvailable = (!turnOffDatabaseConnection);

        notifySimulationListeners(SystemEventType.Build);

        try {
            currentExperiment = ExperimentManager.getInstance()
                .setupExperiment(currentExperiment, models.toArray(new SimulationManager[models.size()]));
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (modelBuild)
            return;

        for (SimulationManager manager : models) {
            manager.buildObjects();
            manager.buildSchedule();
        }

        modelBuild = true;
    }

    /**
     * Return true if buildModels() method has been called. False otherwise.
     *
     * @return True is models have been built, false otherwise.
     */
    public boolean getModelBuildStatus() {
        return modelBuild;
    }

    /**
     * Dispose from memory all running models. Return an array representing the
     * Class of each disposed models. It is used by rebuildModels().
     *
     * @return The list of disposed models.
     */
    public synchronized Class<?>[] disposeModels() {
        eventQueue.clear();

        modelBuild = false;

        // Get models' class type and dispose
        Class<?>[] cls = new Class[models.size()];
        for (int i = 0; i < models.size(); i++) {
            SimulationManager model = models.get(i);
            cls[i] = model.getClass();
            model.dispose();
        }
        models.clear();
        modelMap.clear();

        System.gc();

        turnOffDatabaseConnectionAvailable = true;

        return cls;
    }

    /**
     * Dispose and rebuild each running model. It is used to restart simulation.
     */
    public void rebuildModels() {
        int k = currentRunNumber;
        disposeModels();
        currentRunNumber = k + 1;

        eventQueue.clear();

        setRandomSeed(randomSeed);

        notifySimulationListeners(SystemEventType.Restart);
        setup();
    }

    /**
     * Set the current random seed.
     *
     * @param newSeed The new random seed.
     */
    public void setRandomSeed(int newSeed) {
        rnd = new MersenneTwister(randomSeed);
        randomSeed = newSeed;
    }

    /**
     * Stops the simulation and call the simulationEnd method of each running
     * model.
     */
    public void end() {
        pause();
        eventQueue.clear();
        performAction(SystemEventType.End);
    }

    /**
     * React to system events.
     *
     * @param actionType Reacts in case of EVENT_SIMULATION_END,
     *                   EVENT_SIMULATION_RESTART, EVENT_SHUTDOWN events.
     */
    public void performAction(SystemEventType actionType) {
        switch (actionType) {
            case Stop -> {
                pause();
                for (SimulationManager model : models) model.dispose();
            }
            case Restart -> rebuildModels();
            case Shutdown -> quit();
            default -> {
            }
        }

        for (EngineListener engineListener : engineListeners) engineListener.onEngineEvent(actionType);
    }

    private synchronized void checkIdle() throws InterruptedException {
        while (!runningStatus)
            wait();
    }

    /**
     * Set current simulation running status.
     */
    public void setRunningStatus(boolean running) {
        runningStatus = running;
        if (runningStatus)
            resumeRun();
    }

    private synchronized void resumeRun() {
        notify();
    }

    public synchronized void step() throws SimulationException {
        if (!modelBuild)
            buildModels();

        eventQueue.step();
        notifySimulationListeners(SystemEventType.Step);
        this.yield();
    }

    protected synchronized void notifySimulationListeners(SystemEventType event) {
        if (engineListeners != null)
            for (EngineListener listener : engineListeners) {
                listener.onEngineEvent(event);
            }
    }

    /**
     * Start the independent thread running simulation. It fires events only if running status is set to true.
     */
    public void run() {
        while (true) {
            try {
                checkIdle();
            } catch (Exception e) {
            }

            try {
                step();
            } catch (SimulationException e1) {
                throw new SimulationRuntimeException(e1);
            }

            if (eventThresold > 0)
                try {
                    sleep(eventThresold);
                } catch (Exception e) {
                    log.log(Level.SEVERE, "Interrupt: " + e.getMessage());
                }
                // this is now called in step() method.
            else
                this.yield();
        }
    }

    public @NonNull Experiment getCurrentExperiment() {
        return currentExperiment == null ? new Experiment() : currentExperiment;
    }
}
